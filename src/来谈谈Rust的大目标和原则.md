# 来谈谈Rust的大目标和原则



> 📌 参考
> 
> * [Rust](https://www.Rust-lang.org/) Rust 官网
> * [Rustacean Principles](https://rustacean-principles.netlify.app/what_is_rust.html) 一组指导开发Rust以及开源组织的原则草案（处于WIP状态）
> * [Rustacean Principles, continued](https://smallcultfollowing.com/babysteps/blog/2021/09/16/rustacean-principles-continued/)
> * [Dyn async traits, part 8: the soul of Rust](https://smallcultfollowing.com/babysteps/blog/2022/09/18/dyn-async-traits-part-8-the-soul-of-Rust/) 使用上面原则探讨dyn async traits功能的设计
> * [What I meant by the "soul of Rust"](https://smallcultfollowing.com/babysteps/blog/2022/09/19/what-i-meant-by-the-soul-of-rust/) 澄清上面一篇文章关于“透明”原则的一些误区
> * [AiC: Adventures in consensus](https://smallcultfollowing.com/babysteps/blog/2019/04/19/aic-adventures-in-consensus/) Rust面对权衡时该怎么做





本文打算对上面几篇文章进行“断章取义”，稍微介绍（结合自己脑补）一下Rust的目标，Rust的语言的一些原则，以及Rust语言如何满足这些原则，为Rust打打广告。（强烈建议阅读原文，毕竟个人的理解可能会有偏差）

（本文假定读者对rust有了解）



***

# Rust的目标以及原则

先从Rust官网摘取一下官方对Rust语言的描述——Rust的终极目标：

> 英文版：A language **empowering** everyone to build reliable and efficient software.
>
> 中文版：一门赋予每个人构建可靠且高效软件能力的语言。

这里的关键词是**赋能**——Rust使得我们无需成为领域专家，也能够构建可靠且高效的软件。（吐槽：Rust的目标不是替代C/C++；也不是发明新概念解决某些新需求）



为了达到这个目标，niko便将这个目标拆解为几个原则/价值观：

* Rust是**可靠的(Reliable)**：可编译则可工作——if it compiles, it works
* Rust是**高性能的(Performant)**：惯用代码高效运行——idiomatic code runs efficiently
* Rust能给予很多**支持(Supportive)**：语言、工具、社区都能提供帮助——the language, tools, and community are here to help
* Rust是**高产效的(Productive)**：些许努力就能做很多——a little effort does a lot of work
* Rust是**透明的(Transparent)**：底层细节可预测且可控制——you can predict and control low-level details
* Rust是**通用的(Versatile)**：你可以用 Rust 做任何事——you can do anything with Rust

这些原则的优先级依次递减（后面几个原则的顺序可能还会有调整）。

我们总是希望，给定任一设计都能满足（或者不违背）这里的原则。但**通常这些原则并不正交，甚至相互掣肘(in tension)**。于是些时候我们可能就会在选择其中一个原则时，被迫违背了另一个原则——这种情况下，倾向于选择优先级更高的原则。Rust的功能总是在这样多方权衡与斗争的情况下设计出来的（最好的情况当然是找到*克服这些权衡*的“第三条路”），这便是**Rust的灵魂所在(the soul of Rust)**。

我觉得这些原则不仅仅可以指导Rust语言本身的设计，平时做框架和库的设计的时候，同样也需要思考这些原则。



这些原则之间还有更深刻的内涵，下面便稍微展开一下：

 <br /> 

## Rust是可靠的(Reliable)

关键词：安全，可靠

可靠性可以说是Rust最重要的目标了，Rust保证自身不出幺蛾子的同时也鼓励程序员写健壮可靠的代码。

“可编译则可工作”是Rust的一大优点，这有利于我们做重构。很多时候在做完一次大规模重构之后，如果程序通过编译那么基本就不会有什么大问题了。



不过Rust的可靠性可能会与Rust的高产效、支持性、全能性不一致。

* Rust的可靠性可能会迫使程序员考虑各种条件，这有违Rust高产效的理念。
* Rust的可靠性可能会带来系统的复杂度，这有违Rust支持性的理念。
* Rust的可靠性可能会过度限制表达力，这有违Rust全能性的理念



Rust的**类型安全**便是支撑Rust可靠性的重要保证。Rust的类型系统保证了safe Rust不出现未定义行为，比如说段错误、数据竞争等。但类型安全当然是有代价的，就正如刚刚所说的可靠性的带来的问题一样。不过Rust同时又给了用户选择的余地：

* 有些错误允许运行时的检查，而非类型在编译时的检查。比如说下标是否越界，我们可以通过`i < arr.len()`来检查。运行时检查可能有时候会稍稍没那么可靠，但又大大地提升了Rust开发的产效。
* rustc也一直致力于提升编译错误信息的友好程度。可能类型导致代码难以理解，但Rust的其它工具也会尽力给出更多精确且友善的信息，帮助你去理解代码。Rust的支持性又从它的工具找补了回来。
* Rust允许编写unsafe的代码。类型检查可能会有误报(false positive)，拦住了本是安全的代码，于是Rust同时也提供了绕过一些检查的unsafe代码，使得Rust仍然可以“做任何事情”。虽然这同样会在局部损伤了Rust的可靠性，但如果没有unsafe，Rust可以做的事情便大打折扣了。（至于unsafe的含义，可以参考我的文章）



除了类型安全，Rust还有其它机制来保证可靠性，比如模式匹配的穷尽性检查(exhaustive check)，它必须要求程序员显式地处理所有情况。等等。

 <br /> 

## Rust是高性能的(Performant)

关键词：抽象，性能

Rust鼓励用户使用抽象，编译器则帮你产生高效的代码。在Rust中，最快的代码通常也是最“高层次“，最“干净”的——Rust会将比如闭包、迭代器、async-await等最常用、又方便的”高级抽象“映射到既高效，内存占用又最少的代码。



Rust的迭代器就是高性能的一大代表——很多时候迭代器会使得代码更简洁，更高级，同时迭代器代码通常都能被编译成循环，还能避免掉数组的边界检查（还有其它优化）。



但Rust追求的高性能，可能会与其它的原则不一致：

* 追求高性能抽象的时候，Rust可能给予不了太多支持，有时还会降低产效。这里的问题是对于这些高效的抽象，其库的设计以及用户的使用，我们可能很难从其它语言中获取到经验，Rust社区同样也缺乏高性能抽象设计的指导，这都需要从零设计或者从零学习。
* 另一方面，Rust的高性能十分依赖编译器的优化，过度明确的代码行为反而会压缩编译器的优化空间，这便与Rust的透明性理念有所违背。这点可能会有点反直觉，在后文讲透明性时再展开。
* Rust的通用性，也容易带来一些性能的损失，当提供给用户更多的选择的时候 同时也会使得编译器难以优化。



所谓的“高性能”抽象，在Rust中又被称作 **零开销抽象(Zero-cost Abstactions)** 。这是借自C++的一个slogan：

> "What you don't use, you don't pay for. And further: What you do use, you couldn't *hand code* any better." -- Bjarne Stroustroup

用Rust提供的抽象都希望尽可能地达到这个目标，高性能主要指的是后半句话。

除此之外，为了留给编译器更多的优化空间，Rust的很多特性都遵循着另一句话——**仅明确所必须的部分(Specify only what's necessary)**。比如说目前Rust的类型的内存布局是没有规范的，于是编译器就可以做一些优化——重排字段的顺序来消除padding，减少内存消耗，优化读取速度；又或者进行"niche optimization"，利用未定义的bits range，表示枚举中不同变体的discriminant。只有在明确需求的时候，才用`repr` 属性来选择使用怎么样的内存布局（也为Rust补回了一点透明性和通用性）。

 <br /> 


## Rust能提供很多支持(Supportive)

关键词：开发体验，社区

Rust的提供了很多开发工具，而且体验非常的不错，比如说rustc, cargo, rust docs, clippy, crates.io, md book等等。而且Rust也拥有一个热情开方包容活跃的社区（总体上doge）。在学习或者开发的各个过程中你都能得到来自Rust的各种帮助。

对于我来说，之前接触过很多语言，而最后让我喜欢上Rust，并且能真正使用上进行生产的，可能最重要的就是这一点了。之前接触的语言要么就是工具配置很麻烦，要么就是库难找，要么就是文档晦涩（或者水平参差不齐），要么就是圈子太小——在真正进入开发之前有很多绊脚石。


不过要做好各方面的支持，也不是那么容易的。困难来自于Rust自身语言的复杂度（可能来自于追求可靠性、高性能、透明性以及通用性），需要付出更多的精力去补充各种文档和打磨各种开发工具；反过来，要做好支持性可能也会影响到Rust的其它原则——因为通常最好的帮助总是需要简单直接的，但是这也局限了Rust其它方面的发展。


<div class="note">

这点与易用性的概念有点接近，虽然易用性很重要，但是Rust并没有把易用性当做核心原则去看待。

</div>


## Rust是高产效的(Productive)

关键词：高质量的生态

<div class="note">

在某些语境下可以翻译为**生产力**

</div>


所有提高开发效率的手段，都可以认为是Rust所追求的。不过我认为其中值得拿出来说是Rust生态的特征——可组合，可移植，兼容性。

重复造轮子这件事在编程界中是一个普遍存在的现象，而重复造轮子会给生产效率大打折扣。需要重复造轮子可能有很多原因，

1. 生态中没有成熟的库，
2. 库不方便集成到当前项目中，
3. 库不支持当前项目的平台，
4. 库在当前版本的编译器中无法编译等等

这些问题都是Rust希望解决的。

首先是第一个问题，我们不得不承认，目前的Rust的生态仍然还不够丰富，但经过几年的发展，现在在crates.io上已经有超过十万个库了，一些优秀的库会慢慢地积累起来（这就需要大家的努力了）。

第二个问题，Rust的cargo + crates.io可以让我们轻松使用已有的库，集成通常不是一件难事。

第三，Rust的编译器支持目前的主流平台，不同平台上的接口在std基本都有对应抽象将差异抹平抹平（比如说文件系统，`std::File`可以支持linux/windows/macos甚至wasm），基本能做到“一次编写到处编译”。

第四，Rust非常重视兼容性问题。Rust有nightly/beta/stable的发布渠道，而一旦一些功能进入了stable渠道之后，在相同Edtion下就几乎不再引入breaking change，除非对应出现unsound的问题（不过这也导致一些不好的设计一点稳定之后就再也无法去掉了）；而跨Edtion可能会引入一些小量的breaking change，但编译器会一步步引导库的作者修掉这问题，比如在edition 2015中trait object允许写成`Trait`，在edition 2018则变成了waring，在edition 2021中则只允许写`dyn Trait`了（当然不改也行，在旧edition中依然可以使用最新版本的rust）。



和其它原则一样，高产效原则也同样可能和其它原则相互掣肘。比如和可靠性，类型安全强迫程序员考虑所有情况，会影响开发效率。等等。

 <br /> 

## Rust是透明的(Transparent)

关键词：控制，预测

Rust希望能让程序员预测以及控制底层的细节。这点与C的目标相似，给予用户对底层比较大的控制权。

Rust到机器码的转换一般是比较直接且直观的，同时Rust的拥有几乎与C一样轻量的运行时，也尽量避免添加一些会增加全局开销语言特性（例如GC）（但也不是没有，比如panic、全局分配器等），使得用户使用Rust时可以避免引入一些额外的“开销”——透明性体现了“零开销抽象”的前半句话。在Rust的透明性加持下，我们可以比较简单的地分析出来一段程序的开销是如何，这在大部分情况都是准确的。

另外一方面则可以透过Rust的透明性，很好地控制底层的行为，尤其是当我们需要编写一些核心的代码时（操作系统内核、嵌入式）。



不过关于Rust的透明性，有两个比较大的误区：

1. 放大了透明性对Rust的重要程度

   有不少人认为Rust所有操作都要精确对应到底层细节，可以完全控制内存布局、分配的，就像C一样。但透明到一定程度边际收益就会变的很低，会暴露很多其实很多无关的细节，造成抽象泄露，反而会带来系统的复杂度。抽象泄露对rust的支持度、产效、通用性都会产生不利的影响。

2. 简单的认为透明性能带来更高的性能

   事实上结合编译器和运行时的优化，一些解释性语言，或者一些带GC特性的语言，在特定场景下，性能上不一定输于Rust；而没有经过精心设计调优的C程序，性能也未必打得过只靠编译器优化的Java。总之透明性并不直接与性能挂钩，反而太过于透明，代码与汇编对应得越直接，留给编译器和运行时优化的空间就不多了，反而性能会劣化。（不过透明确实有利于分析性能与调试）



透明性很重要，但毕竟不是Rust的唯一目标，或者说Rust的这几个重要的原则都是为了具体需求服务的，更重要的是问题的解决方案。当面对一个个具体的问题的时候，可能会有多全齐美，满足所有原则的方案，我们会去追求它，但大多数情况会存在权衡（当然除了原则还得考虑时间成本），如何在权衡中找到最优解才是Rust价值观的关键所在（前文说的是灵魂）。

 <br /> 

## Rust是通用的(Versatile)

关键词：全能

Rust的通用性则是追求用户能用Rust编写任何程序，从上写应用程序、Web服务器，到下操作系统内核以及嵌入式。

当编写上层应用时，可以使用Rust的各种高级抽象；当编写底层基建的时候，Rust暴露了系统的所有能力，程序员无需切换到C语言，就可以使用到这些功能。后者是很多其他“应用层”语言是做不到的，要不通过ffi调用C，要不魔改运行时。

其实刚刚的前面提到的原则中，其实也隐含地体现了这个原则。Rust在“关上一删门的时候，都会给你开一扇窗”，让用户选择使用什么功能，让用户按需求取舍：

* 比如需要可靠时则可以选择类型系统，更需要开发效率时可以选择运行时检查，需要实现底层功能时还可以选择unsafe去避开检查。
* 比如定义类型需要性能的时候，可以依赖编译器决定类型的内存布局，当你需要精确定义时可以使用`repr`来描述布局等等。



Rust通用性也会影响到其它的原则，比如支持性和性能：

* 系统的一些底层的功能大多数时候都是丑陋的，很难使用，这点与支持性有所违背。
* 当完成同一件事情提供很多种选择的时候，也会影响编译器的优化。


 <br /> 


# 我们什么情况下使用Rust

根据上面的一些原则，我们可以得到一些我们应该使用Rust的一些场景：

* 如果我们关心安全性和正确性时，我们可以使用Rust：Rust的可靠性让我们远离内存安全的bug或者数据竞争；而且Rust的各种机制也会帮助程序员编写健壮可靠的程序，能让我们及早发现问题。（见可靠性）
* 如果我们关心程序的资源使用情况时，我们可以使用Rust：Rust在默认情况下就能让我们得到低开销高性能的程序（见高性能）；另外Rust的透明性可以让我们更方便地进行调优（见透明性）。
* 如果我们关心程序的可移植性时，我们可以使用Rust：Rust的标准库和工具链可以跨平台使用（见高产效）。同时也可以在不同平台上使用那些专供的能力（见全能性）。



不过有些场景Rust可能不是首选的：

* 如果你编写的代码是临时的，可以不用Rust。
* 如果你重视敏捷开发，且交付时间比较紧迫时，可以不用Rust。
* 如果你不关心程序使用了多少资源的，可以不用Rust。

当然，如果你对Rust已经很熟悉了，其实非核心场景也可以首选Rust的。其实在敏捷开发方面，Rust也是做得不错的，毕竟高产效也是Rust的目标之一。

 <br /> 

# 案例分析

刚刚啰里八嗦讲了这么多，我们最后再来看一下，这些原则是怎么起作用的。

 <br /> 

## 错误处理

主流的错误处理方式是`try-catch`，而rust选择的则是`?`运算符。最后Rust决定使用这个设计可以说是经历了非常非常非常长的讨论时间，但从结果上来看，`?`运算符确实相对于`try-catch`更能满足上面的这些原则。



`throw-try-catch`：

* 可靠吗？：可能不，因为`throw`抛出的错误，很难看出错误发生的位置，导致写出的代码容易崩溃。不过Java的checked expection能一定程度缓解这个问题。
* 高性能吗？：不，因为`throw-try-catch`需要额外的运行时支持，抛出错误的时候有一定的性能开销。
* 高产效吗？：是的，因为`throw-try-catch`允许程序员不需要付出什么心智负担就可以抛出一个错误。
* 透明吗？：可能不，因为我们无法控制`throw-try-catch`的行为，因为这一部分完全由运行时决定。



不过`?`操作符则能很好地解决传统错误处理的一些问题，既需要能简单地抛出错误，也可以进行精细的错误处理：

* 可靠吗？：是的，因为本质上`?`返回的类型是`Result`和`Option`，当我们处理错误的时候就得考虑所有情况。（不过类似`anyhow`这些库则将这个情况的考虑推迟到了运行时，会有损可靠性）
* 高性能吗？：没有影响，因为`?`的抛出本质只是函数返回，没有额外引入其它开销，也没有引入可以优化的地方。
* 高产效吗？：是的，因为我们随时可以通过`?`抛出错误。
* 透明吗？：是的，`?`抛出错误能直接映射到函数的返回，同时通过`?`操作符的位置我们也可以轻松找到那些会抛出错误的位置。
