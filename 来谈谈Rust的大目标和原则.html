<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>来谈谈Rust的大目标和原则 - Rust写作计划</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/learningrust.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="简介.html">简介</a></li><li class="chapter-item expanded "><a href="Rust整体介绍.html"><strong aria-hidden="true">1.</strong> Rust整体介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="来谈谈Rust的大目标和原则.html" class="active"><strong aria-hidden="true">1.1.</strong> 来谈谈Rust的大目标和原则</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">1.2.</strong> Rust项目，团队，工作组，社区，基金会，以及如何贡献代码</a></li></ol></li><li class="chapter-item expanded "><a href="Rust基础概念.html"><strong aria-hidden="true">2.</strong> Rust基础概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="当我们在rust中讨论“所有权”的时候，究竟是在说什么.html"><strong aria-hidden="true">2.1.</strong> 当我们在Rust中讨论“所有权”的时候，究竟是在说什么</a></li><li class="chapter-item expanded "><a href="当我们在rust中讨论unsafe的时候，究竟是在说什么.html"><strong aria-hidden="true">2.2.</strong> 当我们在Rust中讨论unsafe的时候，究竟是在说什么</a></li><li class="chapter-item expanded "><a href="稍微聊聊Rust中的Invariant.html"><strong aria-hidden="true">2.3.</strong> 稍微聊聊Rust中的Invariant —— 那些必须保持的性质</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">2.4.</strong> Rust程序的组成</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">2.5.</strong> Rust的类型系统(type/trait/borrow checker等)</a></li><li class="chapter-item expanded "><a href="rust中的implItem.html"><strong aria-hidden="true">2.6.</strong> Rust中的impl item</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">2.7.</strong> 宏</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">2.8.</strong> 库/链接</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">2.9.</strong> 工具链相关</a></li></ol></li><li class="chapter-item expanded "><a href="一些语言和库的细节.html"><strong aria-hidden="true">3.</strong> 一些语言和库的细节</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="讲讲让我熬了几天夜的DropCheck.html"><strong aria-hidden="true">3.1.</strong> 讲讲让我熬了几天夜的Drop Check</a></li><li class="chapter-item expanded "><a href="RustPinApi真难啊.html"><strong aria-hidden="true">3.2.</strong> Rust Pin api真难啊</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">3.3.</strong> 多线程</a></li></ol></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">4.</strong> 设计模式以及编码技巧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="StateMachinePattern.html"><strong aria-hidden="true">4.1.</strong> State machine Pattern</a></li><li class="chapter-item expanded "><a href="Rust设计模式探索_crate间接口相互调用.html"><strong aria-hidden="true">4.2.</strong> crate间接口相互调用</a></li></ol></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">5.</strong> 优秀开源项目架构介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">5.1.</strong> rust analyzer</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">5.2.</strong> rustc</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">5.3.</strong> servo</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust写作计划</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="来谈谈rust的大目标和原则"><a class="header" href="#来谈谈rust的大目标和原则">来谈谈Rust的大目标和原则</a></h1>
<blockquote>
<p>📌 参考</p>
<ul>
<li><a href="https://www.Rust-lang.org/">Rust</a> Rust 官网</li>
<li><a href="https://rustacean-principles.netlify.app/what_is_rust.html">Rustacean Principles</a> 一组指导开发Rust以及开源组织的原则草案（处于WIP状态）</li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2021/09/16/rustacean-principles-continued/">Rustacean Principles, continued</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2022/09/18/dyn-async-traits-part-8-the-soul-of-Rust/">Dyn async traits, part 8: the soul of Rust</a> 使用上面原则探讨dyn async traits功能的设计</li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2022/09/19/what-i-meant-by-the-soul-of-rust/">What I meant by the &quot;soul of Rust&quot;</a> 澄清上面一篇文章关于“透明”原则的一些误区</li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2019/04/19/aic-adventures-in-consensus/">AiC: Adventures in consensus</a> Rust面对权衡时该怎么做</li>
</ul>
</blockquote>
<p>本文打算对上面几篇文章进行“断章取义”，稍微介绍（结合自己脑补）一下Rust的目标，Rust的语言的一些原则，以及Rust语言如何满足这些原则，为Rust打打广告。（强烈建议阅读原文，毕竟个人的理解可能会有偏差）</p>
<p>（本文假定读者对rust有了解）</p>
<hr />
<h1 id="rust的目标以及原则"><a class="header" href="#rust的目标以及原则">Rust的目标以及原则</a></h1>
<p>先从Rust官网摘取一下官方对Rust语言的描述——Rust的终极目标：</p>
<blockquote>
<p>英文版：A language <strong>empowering</strong> everyone to build reliable and efficient software.</p>
<p>中文版：一门赋予每个人构建可靠且高效软件能力的语言。</p>
</blockquote>
<p>这里的关键词是<strong>赋能</strong>——Rust使得我们无需成为领域专家，也能够构建可靠且高效的软件。（吐槽：Rust的目标不是替代C/C++；也不是发明新概念解决某些新需求）</p>
<p>为了达到这个目标，niko便将这个目标拆解为几个原则/价值观：</p>
<ul>
<li>Rust是<strong>可靠的(Reliable)</strong>：可编译则可工作——if it compiles, it works</li>
<li>Rust是<strong>高性能的(Performant)</strong>：惯用代码高效运行——idiomatic code runs efficiently</li>
<li>Rust能给予很多<strong>支持(Supportive)</strong>：语言、工具、社区都能提供帮助——the language, tools, and community are here to help</li>
<li>Rust是<strong>高产效的(Productive)</strong>：些许努力就能做很多——a little effort does a lot of work</li>
<li>Rust是<strong>透明的(Transparent)</strong>：底层细节可预测且可控制——you can predict and control low-level details</li>
<li>Rust是<strong>通用的(Versatile)</strong>：你可以用 Rust 做任何事——you can do anything with Rust</li>
</ul>
<p>这些原则的优先级依次递减（后面几个原则的顺序可能还会有调整）。</p>
<p>我们总是希望，给定任一设计都能满足（或者不违背）这里的原则。但<strong>通常这些原则并不正交，甚至相互掣肘(in tension)</strong>。于是些时候我们可能就会在选择其中一个原则时，被迫违背了另一个原则——这种情况下，倾向于选择优先级更高的原则。Rust的功能总是在这样多方权衡与斗争的情况下设计出来的（最好的情况当然是找到<em>克服这些权衡</em>的“第三条路”），这便是<strong>Rust的灵魂所在(the soul of Rust)</strong>。</p>
<p>我觉得这些原则不仅仅可以指导Rust语言本身的设计，平时做框架和库的设计的时候，同样也需要思考这些原则。</p>
<p>这些原则之间还有更深刻的内涵，下面便稍微展开一下：</p>
<br /> 
<h2 id="rust是可靠的reliable"><a class="header" href="#rust是可靠的reliable">Rust是可靠的(Reliable)</a></h2>
<p>关键词：安全，可靠</p>
<p>可靠性可以说是Rust最重要的目标了，Rust保证自身不出幺蛾子的同时也鼓励程序员写健壮可靠的代码。</p>
<p>“可编译则可工作”是Rust的一大优点，这有利于我们做重构。很多时候在做完一次大规模重构之后，如果程序通过编译那么基本就不会有什么大问题了。</p>
<p>不过Rust的可靠性可能会与Rust的高产效、支持性、全能性不一致。</p>
<ul>
<li>Rust的可靠性可能会迫使程序员考虑各种条件，这有违Rust高产效的理念。</li>
<li>Rust的可靠性可能会带来系统的复杂度，这有违Rust支持性的理念。</li>
<li>Rust的可靠性可能会过度限制表达力，这有违Rust全能性的理念</li>
</ul>
<p>Rust的<strong>类型安全</strong>便是支撑Rust可靠性的重要保证。Rust的类型系统保证了safe Rust不出现未定义行为，比如说段错误、数据竞争等。但类型安全当然是有代价的，就正如刚刚所说的可靠性的带来的问题一样。不过Rust同时又给了用户选择的余地：</p>
<ul>
<li>有些错误允许运行时的检查，而非类型在编译时的检查。比如说下标是否越界，我们可以通过<code>i &lt; arr.len()</code>来检查。运行时检查可能有时候会稍稍没那么可靠，但又大大地提升了Rust开发的产效。</li>
<li>rustc也一直致力于提升编译错误信息的友好程度。可能类型导致代码难以理解，但Rust的其它工具也会尽力给出更多精确且友善的信息，帮助你去理解代码。Rust的支持性又从它的工具找补了回来。</li>
<li>Rust允许编写unsafe的代码。类型检查可能会有误报(false positive)，拦住了本是安全的代码，于是Rust同时也提供了绕过一些检查的unsafe代码，使得Rust仍然可以“做任何事情”。虽然这同样会在局部损伤了Rust的可靠性，但如果没有unsafe，Rust可以做的事情便大打折扣了。（至于unsafe的含义，可以参考我的文章）</li>
</ul>
<p>除了类型安全，Rust还有其它机制来保证可靠性，比如模式匹配的穷尽性检查(exhaustive check)，它必须要求程序员显式地处理所有情况。等等。</p>
<br /> 
<h2 id="rust是高性能的performant"><a class="header" href="#rust是高性能的performant">Rust是高性能的(Performant)</a></h2>
<p>关键词：抽象，性能</p>
<p>Rust鼓励用户使用抽象，编译器则帮你产生高效的代码。在Rust中，最快的代码通常也是最“高层次“，最“干净”的——Rust会将比如闭包、迭代器、async-await等最常用、又方便的”高级抽象“映射到既高效，内存占用又最少的代码。</p>
<p>Rust的迭代器就是高性能的一大代表——很多时候迭代器会使得代码更简洁，更高级，同时迭代器代码通常都能被编译成循环，还能避免掉数组的边界检查（还有其它优化）。</p>
<p>但Rust追求的高性能，可能会与其它的原则不一致：</p>
<ul>
<li>追求高性能抽象的时候，Rust可能给予不了太多支持，有时还会降低产效。这里的问题是对于这些高效的抽象，其库的设计以及用户的使用，我们可能很难从其它语言中获取到经验，Rust社区同样也缺乏高性能抽象设计的指导，这都需要从零设计或者从零学习。</li>
<li>另一方面，Rust的高性能十分依赖编译器的优化，过度明确的代码行为反而会压缩编译器的优化空间，这便与Rust的透明性理念有所违背。这点可能会有点反直觉，在后文讲透明性时再展开。</li>
<li>Rust的通用性，也容易带来一些性能的损失，当提供给用户更多的选择的时候 同时也会使得编译器难以优化。</li>
</ul>
<p>所谓的“高性能”抽象，在Rust中又被称作 <strong>零开销抽象(Zero-cost Abstactions)</strong> 。这是借自C++的一个slogan：</p>
<blockquote>
<p>&quot;What you don't use, you don't pay for. And further: What you do use, you couldn't <em>hand code</em> any better.&quot; -- Bjarne Stroustroup</p>
</blockquote>
<p>用Rust提供的抽象都希望尽可能地达到这个目标，高性能主要指的是后半句话。</p>
<p>除此之外，为了留给编译器更多的优化空间，Rust的很多特性都遵循着另一句话——<strong>仅明确所必须的部分(Specify only what's necessary)</strong>。比如说目前Rust的类型的内存布局是没有规范的，于是编译器就可以做一些优化——重排字段的顺序来消除padding，减少内存消耗，优化读取速度；又或者进行&quot;niche optimization&quot;，利用未定义的bits range，表示枚举中不同变体的discriminant。只有在明确需求的时候，才用<code>repr</code> 属性来选择使用怎么样的内存布局（也为Rust补回了一点透明性和通用性）。</p>
<br /> 
<h2 id="rust能提供很多支持supportive"><a class="header" href="#rust能提供很多支持supportive">Rust能提供很多支持(Supportive)</a></h2>
<p>关键词：开发体验，社区</p>
<p>Rust的提供了很多开发工具，而且体验非常的不错，比如说rustc, cargo, rust docs, clippy, crates.io, md book等等。而且Rust也拥有一个热情开方包容活跃的社区（总体上doge）。在学习或者开发的各个过程中你都能得到来自Rust的各种帮助。</p>
<p>对于我来说，之前接触过很多语言，而最后让我喜欢上Rust，并且能真正使用上进行生产的，可能最重要的就是这一点了。之前接触的语言要么就是工具配置很麻烦，要么就是库难找，要么就是文档晦涩（或者水平参差不齐），要么就是圈子太小——在真正进入开发之前有很多绊脚石。</p>
<p>不过要做好各方面的支持，也不是那么容易的。困难来自于Rust自身语言的复杂度（可能来自于追求可靠性、高性能、透明性以及通用性），需要付出更多的精力去补充各种文档和打磨各种开发工具；反过来，要做好支持性可能也会影响到Rust的其它原则——因为通常最好的帮助总是需要简单直接的，但是这也局限了Rust其它方面的发展。</p>
<div class="note">
<p>这点与易用性的概念有点接近，虽然易用性很重要，但是Rust并没有把易用性当做核心原则去看待。</p>
</div>
<h2 id="rust是高产效的productive"><a class="header" href="#rust是高产效的productive">Rust是高产效的(Productive)</a></h2>
<p>关键词：高质量的生态</p>
<div class="note">
<p>在某些语境下可以翻译为<strong>生产力</strong></p>
</div>
<p>所有提高开发效率的手段，都可以认为是Rust所追求的。不过我认为其中值得拿出来说是Rust生态的特征——可组合，可移植，兼容性。</p>
<p>重复造轮子这件事在编程界中是一个普遍存在的现象，而重复造轮子会给生产效率大打折扣。需要重复造轮子可能有很多原因，</p>
<ol>
<li>生态中没有成熟的库，</li>
<li>库不方便集成到当前项目中，</li>
<li>库不支持当前项目的平台，</li>
<li>库在当前版本的编译器中无法编译等等</li>
</ol>
<p>这些问题都是Rust希望解决的。</p>
<p>首先是第一个问题，我们不得不承认，目前的Rust的生态仍然还不够丰富，但经过几年的发展，现在在crates.io上已经有超过十万个库了，一些优秀的库会慢慢地积累起来（这就需要大家的努力了）。</p>
<p>第二个问题，Rust的cargo + crates.io可以让我们轻松使用已有的库，集成通常不是一件难事。</p>
<p>第三，Rust的编译器支持目前的主流平台，不同平台上的接口在std基本都有对应抽象将差异抹平抹平（比如说文件系统，<code>std::File</code>可以支持linux/windows/macos甚至wasm），基本能做到“一次编写到处编译”。</p>
<p>第四，Rust非常重视兼容性问题。Rust有nightly/beta/stable的发布渠道，而一旦一些功能进入了stable渠道之后，在相同Edtion下就几乎不再引入breaking change，除非对应出现unsound的问题（不过这也导致一些不好的设计一点稳定之后就再也无法去掉了）；而跨Edtion可能会引入一些小量的breaking change，但编译器会一步步引导库的作者修掉这问题，比如在edition 2015中trait object允许写成<code>Trait</code>，在edition 2018则变成了waring，在edition 2021中则只允许写<code>dyn Trait</code>了（当然不改也行，在旧edition中依然可以使用最新版本的rust）。</p>
<p>和其它原则一样，高产效原则也同样可能和其它原则相互掣肘。比如和可靠性，类型安全强迫程序员考虑所有情况，会影响开发效率。等等。</p>
<br /> 
<h2 id="rust是透明的transparent"><a class="header" href="#rust是透明的transparent">Rust是透明的(Transparent)</a></h2>
<p>关键词：控制，预测</p>
<p>Rust希望能让程序员预测以及控制底层的细节。这点与C的目标相似，给予用户对底层比较大的控制权。</p>
<p>Rust到机器码的转换一般是比较直接且直观的，同时Rust的拥有几乎与C一样轻量的运行时，也尽量避免添加一些会增加全局开销语言特性（例如GC）（但也不是没有，比如panic、全局分配器等），使得用户使用Rust时可以避免引入一些额外的“开销”——透明性体现了“零开销抽象”的前半句话。在Rust的透明性加持下，我们可以比较简单的地分析出来一段程序的开销是如何，这在大部分情况都是准确的。</p>
<p>另外一方面则可以透过Rust的透明性，很好地控制底层的行为，尤其是当我们需要编写一些核心的代码时（操作系统内核、嵌入式）。</p>
<p>不过关于Rust的透明性，有两个比较大的误区：</p>
<ol>
<li>
<p>放大了透明性对Rust的重要程度</p>
<p>有不少人认为Rust所有操作都要精确对应到底层细节，可以完全控制内存布局、分配的，就像C一样。但透明到一定程度边际收益就会变的很低，会暴露很多其实很多无关的细节，造成抽象泄露，反而会带来系统的复杂度。抽象泄露对rust的支持度、产效、通用性都会产生不利的影响。</p>
</li>
<li>
<p>简单的认为透明性能带来更高的性能</p>
<p>事实上结合编译器和运行时的优化，一些解释性语言，或者一些带GC特性的语言，在特定场景下，性能上不一定输于Rust；而没有经过精心设计调优的C程序，性能也未必打得过只靠编译器优化的Java。总之透明性并不直接与性能挂钩，反而太过于透明，代码与汇编对应得越直接，留给编译器和运行时优化的空间就不多了，反而性能会劣化。（不过透明确实有利于分析性能与调试）</p>
</li>
</ol>
<p>透明性很重要，但毕竟不是Rust的唯一目标，或者说Rust的这几个重要的原则都是为了具体需求服务的，更重要的是问题的解决方案。当面对一个个具体的问题的时候，可能会有多全齐美，满足所有原则的方案，我们会去追求它，但大多数情况会存在权衡（当然除了原则还得考虑时间成本），如何在权衡中找到最优解才是Rust价值观的关键所在（前文说的是灵魂）。</p>
<br /> 
<h2 id="rust是通用的versatile"><a class="header" href="#rust是通用的versatile">Rust是通用的(Versatile)</a></h2>
<p>关键词：全能</p>
<p>Rust的通用性则是追求用户能用Rust编写任何程序，从上写应用程序、Web服务器，到下操作系统内核以及嵌入式。</p>
<p>当编写上层应用时，可以使用Rust的各种高级抽象；当编写底层基建的时候，Rust暴露了系统的所有能力，程序员无需切换到C语言，就可以使用到这些功能。后者是很多其他“应用层”语言是做不到的，要不通过ffi调用C，要不魔改运行时。</p>
<p>其实刚刚的前面提到的原则中，其实也隐含地体现了这个原则。Rust在“关上一删门的时候，都会给你开一扇窗”，让用户选择使用什么功能，让用户按需求取舍：</p>
<ul>
<li>比如需要可靠时则可以选择类型系统，更需要开发效率时可以选择运行时检查，需要实现底层功能时还可以选择unsafe去避开检查。</li>
<li>比如定义类型需要性能的时候，可以依赖编译器决定类型的内存布局，当你需要精确定义时可以使用<code>repr</code>来描述布局等等。</li>
</ul>
<p>Rust通用性也会影响到其它的原则，比如支持性和性能：</p>
<ul>
<li>系统的一些底层的功能大多数时候都是丑陋的，很难使用，这点与支持性有所违背。</li>
<li>当完成同一件事情提供很多种选择的时候，也会影响编译器的优化。</li>
</ul>
<br /> 
<h1 id="我们什么情况下使用rust"><a class="header" href="#我们什么情况下使用rust">我们什么情况下使用Rust</a></h1>
<p>根据上面的一些原则，我们可以得到一些我们应该使用Rust的一些场景：</p>
<ul>
<li>如果我们关心安全性和正确性时，我们可以使用Rust：Rust的可靠性让我们远离内存安全的bug或者数据竞争；而且Rust的各种机制也会帮助程序员编写健壮可靠的程序，能让我们及早发现问题。（见可靠性）</li>
<li>如果我们关心程序的资源使用情况时，我们可以使用Rust：Rust在默认情况下就能让我们得到低开销高性能的程序（见高性能）；另外Rust的透明性可以让我们更方便地进行调优（见透明性）。</li>
<li>如果我们关心程序的可移植性时，我们可以使用Rust：Rust的标准库和工具链可以跨平台使用（见高产效）。同时也可以在不同平台上使用那些专供的能力（见全能性）。</li>
</ul>
<p>不过有些场景Rust可能不是首选的：</p>
<ul>
<li>如果你编写的代码是临时的，可以不用Rust。</li>
<li>如果你重视敏捷开发，且交付时间比较紧迫时，可以不用Rust。</li>
<li>如果你不关心程序使用了多少资源的，可以不用Rust。</li>
</ul>
<p>当然，如果你对Rust已经很熟悉了，其实非核心场景也可以首选Rust的。其实在敏捷开发方面，Rust也是做得不错的，毕竟高产效也是Rust的目标之一。</p>
<br /> 
<h1 id="案例分析"><a class="header" href="#案例分析">案例分析</a></h1>
<p>刚刚啰里八嗦讲了这么多，我们最后再来看一下，这些原则是怎么起作用的。</p>
<br /> 
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>主流的错误处理方式是<code>try-catch</code>，而rust选择的则是<code>?</code>运算符。最后Rust决定使用这个设计可以说是经历了非常非常非常长的讨论时间，但从结果上来看，<code>?</code>运算符确实相对于<code>try-catch</code>更能满足上面的这些原则。</p>
<p><code>throw-try-catch</code>：</p>
<ul>
<li>可靠吗？：可能不，因为<code>throw</code>抛出的错误，很难看出错误发生的位置，导致写出的代码容易崩溃。不过Java的checked expection能一定程度缓解这个问题。</li>
<li>高性能吗？：不，因为<code>throw-try-catch</code>需要额外的运行时支持，抛出错误的时候有一定的性能开销。</li>
<li>高产效吗？：是的，因为<code>throw-try-catch</code>允许程序员不需要付出什么心智负担就可以抛出一个错误。</li>
<li>透明吗？：可能不，因为我们无法控制<code>throw-try-catch</code>的行为，因为这一部分完全由运行时决定。</li>
</ul>
<p>不过<code>?</code>操作符则能很好地解决传统错误处理的一些问题，既需要能简单地抛出错误，也可以进行精细的错误处理：</p>
<ul>
<li>可靠吗？：是的，因为本质上<code>?</code>返回的类型是<code>Result</code>和<code>Option</code>，当我们处理错误的时候就得考虑所有情况。（不过类似<code>anyhow</code>这些库则将这个情况的考虑推迟到了运行时，会有损可靠性）</li>
<li>高性能吗？：没有影响，因为<code>?</code>的抛出本质只是函数返回，没有额外引入其它开销，也没有引入可以优化的地方。</li>
<li>高产效吗？：是的，因为我们随时可以通过<code>?</code>抛出错误。</li>
<li>透明吗？：是的，<code>?</code>抛出错误能直接映射到函数的返回，同时通过<code>?</code>操作符的位置我们也可以轻松找到那些会抛出错误的位置。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Rust整体介绍.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="todo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Rust整体介绍.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="todo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
